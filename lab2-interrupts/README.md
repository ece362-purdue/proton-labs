# Lab 2
## Interrupts

### Table of Contents
<br>

| Step | Description | Points |
|------|-------------|--------|
| 0.1 | Set up your environment |   |
| 0.2 | Read about interrupts |   |
| 1 | Read the datasheet | 30 |
| 2 | Configure external interrupts | 10 |
| 3 | Configure Platform Timer interrupts | 20 |
| 4 | Configure doorbell interrupts | 20 |
| 5 | In-Lab Checkoff Step | 20* |
| &nbsp; | Total: | 100 |
<br>

\* - You must get your whole lab checked off before the end of your lab section to avoid a late penalty of 20%.

### Introduction

A key concept in embedded systems is the need to process external stimuli, like a button press, or when a sensor detects a change in its environment.  However, the microcontroller may already be busy executing another long running task - maybe it's waiting on a second sensor, or its busy updating a large display.  This is actually a very common scenario you'll encounter when you start thinking about your course project - how do you get your microcontroller to do a lot of different things at the same time?  In this lab, we'll explore how to use **interrupts** to handle these situations.

An interrupt, or event, or trap, is a signal that is generated by the hardware or software when an event occurs that needs immediate attention.  Once it's **fired** from an interrupt source, the interrupt signal arrives at the CPU, which saves what it's doing, and then - if the conditions are right and the correct bits are set - the CPU will execute a special function called an **interrupt service routine** (ISR), which you will implement.

There's three types of interrupts we can explore that's common to most microcontrollers:
1. **External Interrupts**: These are triggered by external hardware.  There are four kinds of interrupts - two level-triggered (logic 1 or logic 0), and two-edge triggered (rising or falling edge).  
    - The difference between the two types is that level-triggered interrupts will keep firing as long as the condition is met, while edge-triggered interrupts will only fire once per "trigger".  For our purposes, edge-triggered interrupts are more useful.
2. **Peripheral Interrupts**: These are triggered by special events that occur on peripherals, such as timers, which can be configured to generate an interrupt when their internal counter reaches a certain value, among other possible events.

But with the Pico 2, we have a very interesting **third** type of interrupt: doorbell interrupts!  If you hadn't noticed, your Pico 2 has two pairs of ARM and RISC-V cores that you can use, and this lab gives you an opportunity to explore how to use them.  Doorbell interrupts are a way for one core to signal the other core that it has something important to do, and the other core will stop what it's doing and execute the corresponding ISR.  This is a very powerful feature that you can use to offload tasks from one core to another, or to signal that a task is complete.

## Instructional Objectives
- To understand the concept of interrupts.
- To learn how to configure an external interrupt on the Pico 2.
- To learn how to configure a platform timer interrupt on the Pico 2.
- To learn how to configure a doorbell interrupt on the Pico 2.

> [!IMPORTANT]
> Similar to 270, 362 labs should be started at home, and checked off in lab.  **Do not wait to start your lab in your lab section, or you will not finish.**  You must be **checked off for all steps in lab** to receive full credit.

### Step 0.1: Set up your environment

Make sure to clone the code repository from GitHub Classroom.  Keep in mind to add, commit and push any changes you make so that your work is accessible from a lab machine. 

Open the template in VScode and with your Debug Probe connected to your Pico 2, click "Flash Project (SWD)".  Open the Serial Monitor to see the output of your program, and press the Reset button so that it prints out again.  You should now see the following:

```text
Interrupts Lab Test Suite for Pico 2
Type 'help' to learn commands.

> 
```

You can then type `help` to learn what commands you can use to test a certain subroutine.  You will use this to demo your implementation and wiring to the TAs.

> [!IMPORTANT]
> For this lab, we'll use the ARM Cortex-M33 cores on the microcontroller, since it is more relevant to the lecture.  Your project is already configured to do this.  This is important to note for step 2.

### Step 0.2: Read about interrupts

In this lab, it's helpful to have an understanding of the layout of the processor cores on your microcontroller.  The Pico 2 has four cores, of which only two are usable at one time, as shown in this diagram ([Figure 6, Chapter 3, RP2350 Datasheet](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A37%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C841.89%2Cnull%5D)):

![Pico 2 Core Layout](core-diagram.png)

You can see the four CPU cores in the middle block, but note how they go through muxes (which only allows a connection to be made to one of the two cores in each pair), and then to the "Split" below the block.  This is where the cores are given access to the ["bus fabric"](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A26%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C709.282%2Cnull%5D) which is a term that refers to the main system bus that connects all the peripherals and memory to the CPU cores.  On every clock cycle, depending on the instructions they execute, the cores read or write to the bus fabric, which then carries those transmissions from or to the peripherals and memory.

The top block is the debugging interface, that allows a debug host (which is your Debug Probe connected to the SWCLK and SWD pins of your Pico 2) to control the core behavior.  Chapter 3 tells us that the debugger allows you to:

- Run, halt and reset the (CPU) cores
- Inspect internal core state such as registers
- Access memory from the coreâ€™s point of view
- Load code onto the device and run it

As for interrupts, we see a bus called "System Interrupts" that connects to all the cores through the IRQ (Interrupt ReQuests).  This is how interrupts reach the CPU cores, causing main program execution to halt and the ISR to run.  

So what interrupts are available?  Scroll down to section 3.2, and you'll see:

- "Cross-core FIFO interrupts: SIO_IRQ_FIFO and SIO_IRQ_FIFO_NS (Section 3.1.5)"
    - Also called "mailboxes", these are used to send ordered messages between cores.
    - We won't worry about these for now.
- "Cross-core doorbell interrupts: SIO_IRQ_BELL and SIO_IRQ_BELL_NS (Section 3.1.6)"
    - These are used to signal the other core that it has something to do, but doesn't necessarily have to be ordered or contain other data like the mailbox interrupt.
- "RISC-V platform timer (also usable by Arm cores): SIO_IRQ_MTIMECMP (Section 3.1.8)"
    - We haven't covered timers yet, but the concept is straightforward - timers are **counters** that increment with every rising edge of the clock signal, with options to be enabled/disabled and to have a maximum roll-over value.  (This should be familiar from ECE 270 - it's the same thing!)
    - This timer can be used to generate interrupts at a certain time, or at a certain interval, relative to the number of "ticks" (increments of counter value) that have passed since the timer was started.  
    - It's called "RISC-V Platform" because the timer is described as part of the **RISC-V instruction set** that dictates how the RISC-V cores should process instructions.  However, since timers are standard on any microcontroller, the ARM cores can configure and use it as well.
- "GPIO interrupts: IO_IRQ_BANK0, IRQ_IO_BANK0_NS, IO_IRQ_QSPI, IO_IRQ_QSPI_NS (Section 9.5)"
    - When an external interrupt occurs, the GPIO pins can be configured to generate an interrupt signal that can be sent to the CPU cores.

### Step 1: Read the datasheet

Make sure you did the reading in Step 0.2, and then read the following sections of the RP2350 datasheet and answer the questions underneath.

[Chapter 3.1.6: Doorbells](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A44%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C147.15%2Cnull%5D)

1. What is the name of the interrupt and the corresponding number that you need to enable to use doorbell interrupts?
2. What register do you need to write to to trigger an interrupt on the opposite core?

You'll notice that there's not any information about **configuring** or **enabling** an interrupt before we can use it, like we did with GPIO pins in the previous lab.  We don't know this yet by just looking at the datasheet, so we'll have to wait until the corresponding step here to find out.  Datasheets are weird like that...

[Chapter 3.1.8: RISC-V Platform Timer](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A45%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C420.246%2Cnull%5D)

3. What pair of registers is associated with the counter value of the timer?
4. What pair of registers is associated with the compare value of the timer?
5. When does the interrupt occur in terms of these two pairs of registers?
6. How do you properly change the compare value of the timer?
7. Look at section 8.5.1 to understand how "Tick Generation" can be used to synchronize timers to real time.  What should the cycle count be for the timer to generate an interrupt every microsecond?

[Chapter 6.5.3: DORMANT State](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A488%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C223.738%2Cnull%5D)

8. The best use case for interrupts is to wake the CPU from a low power state when an event occurs.  How do you enter the DORMANT state?  (We are using the crystal oscillator for the clock source.)
9. To enable waking from the DORMANT state by a **specific** GPIO pin interrupt, what register do you need to write to?
10. A code example was provided to demonstrate how to enter the DORMANT state further down under this section, with a link to a "Pico Extras" example.  In it, scroll down to `processor_deep_sleep`, where you'll see code to put either the RISC-V cores or the ARM cores into the DORMANT state.  Note down the line(s) needed to do this for the **ARM** cores.

> [!NOTE]
> *Why use the "Dormant" state over the "Sleep" state?*
> 
> In "Sleep", the clocks are still running to various peripherals (especially ones that could receive a serial data transmission, which we'll get to in later labs), and the CPU is still running, but the CPU is halted.  In "Dormant", the clocks are stopped to all peripherals, and the CPU is halted.  
> 
> When we start implementing external interrupts, the only thing we're expecting to change is a GPIO pin, so it's safe to turn off all clocks.  This is especially useful for battery-powered devices, where you want to save as much power as possible.
> 
> However, for the timer and doorbell interrupts, we still need an active clock signal since both the Platform Timer and the CPU cores still need a clock to function, so we'll use the "Sleep" state.  In such cases, the interrupts originates **from** the peripherals, so turning off the clock will not do us any good!

In [Chapter 3.2: Interrupts](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A84%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C361.924%2Cnull%5D), identify the IRQ numbers that correspond to the RISC-V Platform Timer and the core-local doorbell interrupt.

> [!IMPORTANT]
> Show your answers for the questions asked above to your TA.  You must have **correct** answers to earn points for this step.  
> 
> Avoid the urge to ask others (AI/LLMs are included in "others") for answers.  These questions are specifically designed to get you used to looking at the datasheet for information, and for *you* to understand the microcontroller's specific configuration.

### Step 2: Configure external interrupts

> [!WARNING]
> At this stage, make sure your Debug Probe is connected to the debug and UART pins of your Pico 2, as described [here](https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html).  Add a `printf` after `stdio_init_all()` and turn on the Serial Monitor in VScode to ensure that you are receiving data from the Pico 2 via the probe.

In this step, you will configure an external interrupt on the Pico 2.  We'll use the pushbuttons on GP20 and GP21 to trigger the interrupt, and we'll set up the Interrupt Service Routine, or ISR, to toggle the onboard LED on/off on GP25.

Configuring interrupts on the Pico 2 is quite complex, so we won't have you pull out the code from the convenience functions this time.  To counter that, we will have you dive into the function we'll give you to understand the overall picture of what is happening.

First, configure GP25 as an output - we'll toggle the LED on and off with all the various interrupt sources we'll use in this lab.  Do this immediately after the `stdio_init_all` call in `main`.  Then add a call to `init_gpio_irq`, which we'll implement next.

The function you want to use is `gpio_set_irq_enabled_with_callback`.  Find the code example for this in the datasheet, and implement the `init_gpio_irq` function to do the following:

1. Configure GP21 as an input.  This is the right pushbutton on your breadboard.
    - You can now use `gpio_init` and `gpio_set_dir` if you wish, since you covered how they work in a prior lab.
2. Using `gpio_set_irq_enabled_with_callback`, configure an interrupt as follows:
    - The interrupt should fire **only** on a rising edge on GP21.
    - The ISR should be named `gpio_callback`.  (Create a new function above this one with a `void` return type and no arguments.)
        - In `gpio_callback`, toggle the current value of GP25.  (Hint: you can do this in one go without needing to read the current value of the pin.  Look around for a function you can use to do this.)
3. Add the line from the code sample to enable the DORMANT state that you found in Step 1.  (Hint: it modifies the `scb_hw->scr` register.)

After the `init_gpio_irq` call in `main`, create an infinite loop.  In it, start the dormant state by writing `asm volatile ("wfi")` - this is the [Wait-For-Interrupt instruction](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A86%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C631.754%2Cnull%5D), and tells your CPU to go to sleep, specifically the dormant state which we configured, until an interrupt occurs, which turns off all clocks and utilizes zero dynamic power.  Add a `sleep_ms(1)` after the `wfi` instruction so that we can see the effect of the interrupt when it wakes up.  Both lines should be in the loop.

Pressing the right pushbutton on your breadboard should cause the Pico 2 to exit the dormant state, execute the ISR, and toggle the green LED on or off.  

Now, enter debugging mode, and set a breakpoint on the `sleep_ms` function.  When you continue the program, the execution should not immediately stop at the `sleep_ms` function until 1) you press the right pushbutton to execute the `gpio_callback` ISR, or 2) you press Pause on the debugger.  Both actions are valid interrupts that will cause the CPU to wake up, and continue to the next line of code after the `wfi` instruction.  

If you look at your Debug Console when you press Pause, you can even see the `SIGINT` signal produced that causes the interrupt and wakes up the CPU:

```
1 "rp2350.dap.core0" received signal SIGINT, Interrupt.
main () at ... lab2.c:40
40	        sleep_ms(1);
```

> [!IMPORTANT]
> Show your implementation to your TA, including the LED turning on and off when you press the pushbutton, and the debugger being able to exit the dormant state when you click Pause.  You must have a **working** implementation to earn **all** points for this step.  Answer their questions about the code you wrote.  One of those questions will be how you found the function needed to toggle the pin.
> 
> Commit all your code and push it to your repository now.  Use a descriptive commit message that mentions the step number.

### Step 3: Configure Platform Timer interrupts

In this step, we'll use the timer to toggle the onboard LED on and off every second.  We'll use the RISC-V platform timer to do this, since it's a simple timer that can be configured to generate an interrupt at a certain time.  We'll explore timers in more detail in the next lab.

At this stage, comment out `init_gpio_irq` in `main()`, and implement the `init_timer_irq` function using the information you found in Step 1.  `init_timer_irq` takes two arguments to control the timer: `cmp`, which should be the **compare** value that should be written to MTIMECMP, and `cycles`, which is the number of clock cycles for the tick generator to count.

However, the datasheet alone unfortunately does not tell us how to do this in C, and even your instructor had quite a bit of trouble finding the functions.  Therefore, we're going to use a new resource that you may not have noticed until now - the **Hardware API** Documentation under the Pico 2 extension.  

Add the following `includes` at the top of the file:

```c
#include "../../rp2_common/hardware_riscv_platform_timer/include/hardware/riscv_platform_timer.h"
#include "../../rp2_common/hardware_ticks/include/hardware/ticks.h"
```

These will give you access to the source code for the functions you'll need.

If you click the extension > Documentation > Hardware APIs, a new window will open showing you the various APIs available for you to use the peripherals on your Pico 2.  Search for the RISC-V Platform Timer API, and in it, identify the functions you need to do the following and implement them in `init_timer_irq`:

1. Using the `hardware_riscv_platform_timer` API, set the MTIMECMP registers using the appropriate functions with the `cmp` value passed as an argument.  Make sure to disable the timer first and re-enable the timer afterward.  To ensure the timer starts at zero, set the MTIME register to 0.  (This is also a hint for later...)

2. Using the `hardware_ticks` API, stop the tick generator for the RISC-V platform timer, and start it again with `cycles` as the new cycle count.  

3. Using the `hardware_irq` API, add `gpio_callback` as a shared handler (**not** the exclusive handler), and enable the interrupt for the RISC-V platform timer.  (You should have found the IRQ number for the timer in Step 1.  If you missed it, it's also in the relevant IRQ API page.)

Finally, in `main`, call `init_timer_irq` with the appropriate `cmp` and `cycles` values to generate an interrupt every second.  The formula is as follows:

<img style="padding: 5px; background: white" src="https://latex.codecogs.com/gif.latex?freq = \frac{clock\_hz}{cycles * cmp}"/>

One `cycles` value is suggested in the datasheet under the Tick Generator section.  Use that, and determine what your `cmp` value should be, and pass those as parameters to `init_timer_irq`.  Leave the infinite loop in place below it, make sure `init_gpio_irq` is commented out, and flash your program to your Pico 2.

You will see that the green onboard LED turns on, but does not blink!  Why is that?

This is a perfect opportunity to explore the **Peripherals** view under your debugger.  Either press F5 (or Fn+F5), or click "Debug Project (SWD)" under the Pico extension menu to start debugging.  By default, you'll stop at the first line of `main`.  

A very common debugging technique is to ensure that the registers we are trying to set are actually being set.  While that may sound ridiculous, keep in mind that we are assuming that the functions are correct.  However, being *correct* is not the same as *doing what we want*!

From the datasheet, we know that the RISC-V Platform Timer triggers an interrupt when the `{MTIMEH,MTIME}` registers (that form a 64-bit value) exceed the value in `{MTIMECMPH,MTIMECMP}`.  So, let's check the values of these registers.  Set a breakpoint inside the `gpio_callback` ISR, so that when the timer interrupt fires, you can check the values of these registers in the **Peripherals** view.

In the left sidebar under the Debug Menu, click **Peripherals** (or **XPeripherals**, depending on your configuration).  If you dive into the functions for changing the `MTIMECMP` registers, you'll see that they're located under `sio_hw`, so we need to look under SIO -> MTIMECMP.  The screenshot below expands some other registers that are also helpful to look at.

![Peripherals View](xperipherals.png)

If you hover over the registers, the extension gives a highly useful description of the register, as well as the value represented as hex, decimal and binary.  Nifty!  Use this to confirm that MTIMECMP is being set correctly.

Since we reset MTIME to 0 in `init_timer_irq`, we should expect that `MTIME` is equal to `MTIMECMP` when the interrupt **first** fires.  (If this was your mistake, go fix it!)  Therefore, when we continue our program, we expect that `MTIME` resets and `MTIMECMP` is set to the correct value, and the LED should blink every second.  Right?  Click Continue here.

Wrong!  When the interrupt fires, it fires almost immediately with no delay, and we see that MTIME is now a value higher than MTIMECMP.  This highlights a problem we didn't anticipate - the timer does not automatically reset MTIME to 0 when it reaches MTIMECMP, and we just read that the interrupt will also fire when MTIME **exceeds** MTIMECMP.  So, we need to reset MTIME to 0 when the interrupt fires.  Add this to the `gpio_callback` ISR, and click "Flash Project (SWD)".  We should now see the green LED blinking!

> [!NOTE]
> *Why didn't you just tell me to do that in the first place?*
> 
> Because you wouldn't have known to check the registers in the Peripherals view, and you wouldn't have known to look at the datasheet to understand the behavior of the timer.  Quirks and problems like these will always happen, and you need to be prepared to use the various tools available to you to help you to debug them.  Sometimes, datasheets and API documentation isn't enough (hard as that may be to believe...)
> 
> One more question to consider - can you set `cycles` any higher than 511?  Why not?  (Hint: look up the definition of the register, that `cycles` is assigned to, in the datasheet.)

> [!IMPORTANT]
> Show your implementation to your TA.  Show the (X)Peripherals view with the MTIME/MTIMECMP registers, and how adding the line to reset MTIME to 0 allows the LED to blink properly.  You must have a **working** implementation to earn **all** points for this step.  Answer their questions about the code you wrote.  One of those questions will be how you found the function needed to toggle the pin.
> 
> Commit all your code and push it to your repository now.  Use a descriptive commit message that mentions the step number.

### Step 4: Configure doorbell interrupts

> [!WARNING]
> Multi-core programming may not be covered in lecture.  If there are any doubts as to how this works, ask your **lab** instructor to clarify them.

Now for the fun part!  We're going to split the operation of pressing a pushbutton to turn an LED on across two cores.  This is perhaps far too simplistic, but as computation scales, you may find it useful to dedicate one core to handling computation and the other to handling all the external stimuli/responses.  

In this step, we'll configure a doorbell interrupt to signal the other core to toggle the onboard LED on or off.  We'll use the left pushbutton on your breadboard to trigger the interrupt, and we'll set up the ISR to toggle the onboard LED on or off on the other core.  Here's a diagram to help visualize this, based on one from the datasheet:

![dual-core](dual-core.png)

This diagram shows the various interaction methods between the cores on the bus fabric, so that the CPU cores can access things like:
- Their own and each other's CPUID (typically just 0 and 1)
- 4x32-byte FIFO queue for each core to pass messages.
- 32 hardware spinlocks for each core to lock shared resources in memory.
- 8 doorbell interrupts "each way" for the cores to signal the other core to do something.
- The RISC-V Platform Timer we configured in Step 3.

The "Secure/Non-Secure SIO" refers to the ability to have secure and non-secure memory regions on the Pico 2, where "secured" code has access to the secure peripherals and memory regions, and the non-secure world has access to the rest.  We won't worry about this for the most part - we're only using the Non-Secure SIO anyway.  

At the top, each core **loads** the same instructions from memory, so our code needs to tell the individual cores to do different things.  We achieve this with if/else statements in the same code.  [Section 5.3](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A377%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C511.598%2Cnull%5D) describes how core 1 can be started with a different block of code.

Comment out `init_timer_irq` and complete the following functions as follows:

- `init_gpio_doorbell_irq` - does exactly the same thing as `init_gpio_irq`, except it adds `core0_gpio_callback` as the ISR.
- `core0_gpio_callback` - triggers a doorbell interrupt on the opposite core.  You have to assign a specific value to a certain register that we discussed in Step 1 to "raise an interrupt on the opposite core".
- `core1_main` - this is the main function for the second core.  In it:
    - Configure GP25 as an output as you did earlier (make sure not to do it in the core 0 `main` as well!).
    - Add `core1_led_callback` as the ISR for when a doorbell interrupt occurs.  The IRQ number for the doorbell interrupt is the same as the one you found in Step 1.  Don't forget to enable the interrupt as well!
    - Add the infinite loop from `main` that executes the `wfi` instruction and sleeps 1 ms after waking.
- `core1_led_callback` - when the doorbell interrupt fires, toggle the LED on GP25.

In `main` which runs on core 0, call `init_gpio_doorbell_irq`, and then use the `multicore_launch_core1` function to start `core1_main` on core 1.  Flash your program to your Pico 2, and press the left pushbutton on your breadboard.  If the LED has already turned on, it may be that the interrupt fired immediately, so press the button again to see the LED toggle on and off... which won't work!  

Try pressing Reset to see if that fixes it, and that should properly recognize the pushbutton at a logic 0, so when you press the Right pushbutton, it turns on the LED, but it doesn't seem to turn off!  Notice, however, that is slightly dimmer than usual... that is a hint that your callback function is being called over and over again, even though we're not pressing a pushbutton.  Why is that?

If we look back at the datasheet under [Section 3.1.6: Doorbells](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf#%5B%7B%22num%22%3A44%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C115%2C147.15%2Cnull%5D), we see that in order to raise a doorbell interrupt, we write to an OUT_SET register, but it seems that we missed that the opposite core also needs to write the same value to an IN_CLR register!  Add this line to `core1_led_callback`, and you should now be able to toggle the LED on and off with the left pushbutton.  (You may have to press Reset after flashing over SWD for this to work properly).

Congratulations on running your first multi-core interruptible embedded program!

> [!IMPORTANT]
> Show your implementation to your TA.  Show the LED turning on and off when you press the left pushbutton, and the LED turning on when you press the right pushbutton.  
> 
> Show your TA that your code runs on different cores by starting the debugger with a breakpoint in `core1_led_callback`, and show that the function is being executed by core 1 in the Call Stack view in the debugger. 
> 
> You must have a **working** implementation to earn **all** points for this step.  Answer their questions about the code you wrote.  One of those questions will be how you found the function needed to toggle the pin.
> 
> Commit all your code and push it to your repository now.  Use a descriptive commit message that mentions the step number.

### Step 5: In-Lab Checkoff Step

> [!CAUTION]
> Make sure you got checked off here: https://engineering.purdue.edu/ece362/checkoff/
> 
> Make sure to upload your confirmation code and verify that it is accepted by Gradescope.  You will know it is accepted if you get the points from Gradescope.
> 
> Before you leave, make sure your station is clean and that you have gathered your belongings, and then call a TA to confirm that you can leave.  Confirm that you have received your checkoffs, that your confirmation code was accepted on Gradescope before logging out and leaving for the day.